Processor trace background information
--------------------------------------

Processor trace allows instruction and/or data information to be
traced. Further details of how this is achieved can be found in the
"Efficient Trace for RISC-V" document which is available from here:

https://github.com/riscv-non-isa/riscv-trace-spec/blob/main/riscv-trace-spec.pdf

In addition python reference models of the trace encoder and trace
decoder can be found here:

https://github.com/riscv-non-isa/riscv-trace-spec/tree/main/referenceFlow

IMPORTANT: In order to use data trace, spike must be built with the --enable-commitlog
configuration option.

Processor trace CSV formats
---------------------------

Both instruction and data trace use a CSV format for the spike
generated output.

Instruction trace
-----------------

The header line generated by spike is:
"VALID,ADDRESS,INSN,PRIVILEGE,EXCEPTION,ECAUSE,TVAL,INTERRUPT"

The first column is a constant value 1 (one) present in all rows of
the output.

The remaining columns are named by their meaning. Identical naming of
columns in spike files is not required, whereas the correct number of
columns and the correct data types are required.

VALID: Always set to 1

ADDRESS: Address of the instruction (%lx format, reg_t)

INSN: Instruction (%lx format, uint64_t)

PRIVILEGE: Privilege level (%x format, uint8_t)

EXCEPTION: Whether an exception occurred (%x format, uint8_t)

ECAUSE: The exception cause value when an exception occurred (%lx format, reg_t)

TVAL: The trap value (%lx format, reg_t)

INTERRUPT: Whether an interrupt occurred (%x format, uint8_t)

Data trace
----------

The header line generated by spike is:
"DRETIRE,DTYPE,DADDR,DSIZE,DATA"

DRETIRE: Whether the instruction retired. Currently this is always set
to 1.

DTYPE: This is the data access type that has been generated. (See
Table 4.12 in the trace specification) (%d format, dtype_t)
  0    Load
  1    Store
  2    reserved
  3    reserved
  4    CSR read-write
  5    CSR read-set
  6    CSR read-clear
  7    reserved
  8    Atomic swap
  9    Atomic add
  10   Atomic AND
  11   Atomic OR
  12   Atomic XOR
  13   Atomic max
  14   Atomic min
  15   Conditional store failure

DADDR: Address of the data access. (%lx format, reg_t)

DSIZE: The data transfer is 2^DSIZE bytes. (%ld format, size_t)

DATA: The data value or values transferred. (hex format, length is
dependent on DSIZE)

Testing
-------

A small collection of tests are included which run spike to generate instruction and data trace
file and then checks the output against expected files. Both 64-bit and 32-bit binaries are
tested.

These can be run by using the script
  tests/processor_trace/run_trace_tests.sh path-to-spike-binary

The binaries and expected files are stored in tests/processor_trace/test_files.
Note that the expected files have been compressed using gzip and that the test script
automatically uncompresses these before comparing with the generated traces.

The output is placed in a sub-directory of the current working directory, called trace_regression.
Each run of the script will remove any previously run tests.

Note that the test binaries were built from the following sources:

vvadd/pmp/mt-matmul source is from:
  https://github.com/riscv-software-src/riscv-tests/tree/master/benchmarks

embench-statemate source is from:
  https://github.com/embench/embench-iot/tree/master/src

  In order to build these tests for RISCV a bash script was written to setup the compile options, prior to calling
  the standard build_all.py script from the embench-iot repository. In addition, a spike entry point was written to work with
  embench. These files, and information on building embench, can be found in
    tests/processor_trace/build_files

br_j_asm is from:
  https://github.com/riscv-non-isa/riscv-trace-spec/tree/main/referenceFlow/tests/examples/br_j_asm (written by Bill McSpadden, Seagate Technology)

  This test can be rebuilt by running cmake (version >= 3.10) on this file:
  https://github.com/riscv-non-isa/riscv-trace-spec/blob/main/referenceFlow/tests/examples/br_j_asm/CMakeLists.txt

Although these tests could be recompiled using the latest RISCV toolchain, this may well break these
tests as they are against expected output files. If the tests were recompiled then the expected
output may well need to be updated as well.
